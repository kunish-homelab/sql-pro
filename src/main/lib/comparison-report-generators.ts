import type { SchemaComparisonResult, TableDiff } from '../../shared/types';

/**
 * Report generators for schema comparison results.
 * These utilities convert comparison results to different report formats (HTML, JSON, Markdown).
 */

// ============ HTML Report Generator ============

export interface HTMLReportOptions {
  /** Include a CSS stylesheet (defaults to true) */
  includeStyles?: boolean;
  /** Title for the report (defaults to 'Schema Comparison Report') */
  title?: string;
}

/**
 * Generates an HTML report with styled diff view for schema comparison.
 *
 * @param comparisonResult - The schema comparison result to export
 * @param options - HTML report configuration
 * @returns HTML formatted string with inline CSS
 */
export function generateHTMLReport(
  comparisonResult: SchemaComparisonResult,
  options: HTMLReportOptions = {}
): string {
  const { includeStyles = true, title = 'Schema Comparison Report' } = options;

  const { sourceType, sourceName, targetType, targetName, comparedAt, tableDiffs, summary } =
    comparisonResult;

  // Generate HTML
  const html = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)}</title>
  ${includeStyles ? generateStyles() : ''}
</head>
<body>
  <div class="container">
    <header>
      <h1>${escapeHtml(title)}</h1>
      <div class="metadata">
        <p><strong>Source:</strong> ${escapeHtml(sourceName)} (${escapeHtml(sourceType)})</p>
        <p><strong>Target:</strong> ${escapeHtml(targetName)} (${escapeHtml(targetType)})</p>
        <p><strong>Compared At:</strong> ${formatTimestamp(comparedAt)}</p>
      </div>
    </header>

    <section class="summary">
      <h2>Summary</h2>
      <div class="summary-grid">
        <div class="summary-card">
          <div class="summary-label">Source Tables</div>
          <div class="summary-value">${summary.sourceTables}</div>
        </div>
        <div class="summary-card">
          <div class="summary-label">Target Tables</div>
          <div class="summary-value">${summary.targetTables}</div>
        </div>
        <div class="summary-card added">
          <div class="summary-label">Tables Added</div>
          <div class="summary-value">${summary.tablesAdded}</div>
        </div>
        <div class="summary-card removed">
          <div class="summary-label">Tables Removed</div>
          <div class="summary-value">${summary.tablesRemoved}</div>
        </div>
        <div class="summary-card modified">
          <div class="summary-label">Tables Modified</div>
          <div class="summary-value">${summary.tablesModified}</div>
        </div>
        <div class="summary-card">
          <div class="summary-label">Tables Unchanged</div>
          <div class="summary-value">${summary.tablesUnchanged}</div>
        </div>
      </div>

      ${summary.totalColumnChanges + summary.totalIndexChanges + summary.totalForeignKeyChanges + summary.totalTriggerChanges > 0 ? `
      <div class="changes-summary">
        <h3>Total Changes</h3>
        <ul>
          ${summary.totalColumnChanges > 0 ? `<li>Columns: <strong>${summary.totalColumnChanges}</strong></li>` : ''}
          ${summary.totalIndexChanges > 0 ? `<li>Indexes: <strong>${summary.totalIndexChanges}</strong></li>` : ''}
          ${summary.totalForeignKeyChanges > 0 ? `<li>Foreign Keys: <strong>${summary.totalForeignKeyChanges}</strong></li>` : ''}
          ${summary.totalTriggerChanges > 0 ? `<li>Triggers: <strong>${summary.totalTriggerChanges}</strong></li>` : ''}
        </ul>
      </div>
      ` : ''}
    </section>

    <section class="table-diffs">
      <h2>Table Differences</h2>
      ${tableDiffs.length === 0 ? '<p class="no-changes">No differences found.</p>' : ''}
      ${tableDiffs.map((tableDiff) => generateTableDiffHTML(tableDiff)).join('\n')}
    </section>

    <footer>
      <p>Generated by SQL Pro - Schema Comparison Tool</p>
    </footer>
  </div>
</body>
</html>`;

  return html;
}

/**
 * Generates HTML for a single table diff
 */
function generateTableDiffHTML(tableDiff: TableDiff): string {
  const { name, diffType, columnDiffs, indexDiffs, foreignKeyDiffs, triggerDiffs } = tableDiff;

  const diffClass = diffType === 'added' ? 'added' : diffType === 'removed' ? 'removed' : diffType === 'modified' ? 'modified' : '';

  return `
    <div class="table-diff ${diffClass}">
      <div class="table-header">
        <h3>${escapeHtml(name)}</h3>
        <span class="badge ${diffClass}">${diffType.toUpperCase()}</span>
      </div>

      ${columnDiffs && columnDiffs.length > 0 ? `
        <div class="diff-section">
          <h4>Column Changes (${columnDiffs.length})</h4>
          <table>
            <thead>
              <tr>
                <th>Column</th>
                <th>Type</th>
                <th>Changes</th>
              </tr>
            </thead>
            <tbody>
              ${columnDiffs.map((col) => `
                <tr class="${col.diffType}">
                  <td><strong>${escapeHtml(col.name)}</strong></td>
                  <td><span class="badge ${col.diffType}">${col.diffType.toUpperCase()}</span></td>
                  <td>
                    ${col.changes ? `
                      ${col.changes.type ? `<div>Type: <code>${escapeHtml(col.changes.type.from)}</code> → <code>${escapeHtml(col.changes.type.to)}</code></div>` : ''}
                      ${col.changes.nullable ? `<div>Nullable: <code>${col.changes.nullable.from}</code> → <code>${col.changes.nullable.to}</code></div>` : ''}
                      ${col.changes.defaultValue ? `<div>Default: <code>${escapeHtml(String(col.changes.defaultValue.from ?? 'NULL'))}</code> → <code>${escapeHtml(String(col.changes.defaultValue.to ?? 'NULL'))}</code></div>` : ''}
                      ${col.changes.isPrimaryKey ? `<div>Primary Key: <code>${col.changes.isPrimaryKey.from}</code> → <code>${col.changes.isPrimaryKey.to}</code></div>` : ''}
                    ` : (col.diffType === 'added' && col.target ? `<div>Type: <code>${escapeHtml(col.target.type)}</code>, Nullable: ${col.target.nullable}</div>` : col.diffType === 'removed' && col.source ? `<div>Type: <code>${escapeHtml(col.source.type)}</code>, Nullable: ${col.source.nullable}</div>` : '')}
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      ` : ''}

      ${indexDiffs && indexDiffs.length > 0 ? `
        <div class="diff-section">
          <h4>Index Changes (${indexDiffs.length})</h4>
          <table>
            <thead>
              <tr>
                <th>Index</th>
                <th>Type</th>
                <th>Details</th>
              </tr>
            </thead>
            <tbody>
              ${indexDiffs.map((idx) => `
                <tr class="${idx.diffType}">
                  <td><strong>${escapeHtml(idx.name)}</strong></td>
                  <td><span class="badge ${idx.diffType}">${idx.diffType.toUpperCase()}</span></td>
                  <td>
                    ${idx.changes ? `
                      ${idx.changes.columns ? `<div>Columns: <code>${escapeHtml(idx.changes.columns.from.join(', '))}</code> → <code>${escapeHtml(idx.changes.columns.to.join(', '))}</code></div>` : ''}
                      ${idx.changes.isUnique ? `<div>Unique: <code>${idx.changes.isUnique.from}</code> → <code>${idx.changes.isUnique.to}</code></div>` : ''}
                    ` : (idx.diffType === 'added' && idx.target ? `<div>Columns: <code>${escapeHtml(idx.target.columns.join(', '))}</code>, Unique: ${idx.target.isUnique}</div>` : idx.diffType === 'removed' && idx.source ? `<div>Columns: <code>${escapeHtml(idx.source.columns.join(', '))}</code>, Unique: ${idx.source.isUnique}</div>` : '')}
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      ` : ''}

      ${foreignKeyDiffs && foreignKeyDiffs.length > 0 ? `
        <div class="diff-section">
          <h4>Foreign Key Changes (${foreignKeyDiffs.length})</h4>
          <table>
            <thead>
              <tr>
                <th>From Column</th>
                <th>Type</th>
                <th>Details</th>
              </tr>
            </thead>
            <tbody>
              ${foreignKeyDiffs.map((fk) => `
                <tr class="${fk.diffType}">
                  <td><strong>${escapeHtml(fk.column)}</strong></td>
                  <td><span class="badge ${fk.diffType}">${fk.diffType.toUpperCase()}</span></td>
                  <td>
                    ${fk.changes ? `
                      ${fk.changes.referencedTable ? `<div>Ref Table: <code>${escapeHtml(fk.changes.referencedTable.from)}</code> → <code>${escapeHtml(fk.changes.referencedTable.to)}</code></div>` : ''}
                      ${fk.changes.referencedColumn ? `<div>Ref Column: <code>${escapeHtml(fk.changes.referencedColumn.from)}</code> → <code>${escapeHtml(fk.changes.referencedColumn.to)}</code></div>` : ''}
                      ${fk.changes.onDelete ? `<div>On Delete: <code>${escapeHtml(fk.changes.onDelete.from ?? 'NO ACTION')}</code> → <code>${escapeHtml(fk.changes.onDelete.to ?? 'NO ACTION')}</code></div>` : ''}
                      ${fk.changes.onUpdate ? `<div>On Update: <code>${escapeHtml(fk.changes.onUpdate.from ?? 'NO ACTION')}</code> → <code>${escapeHtml(fk.changes.onUpdate.to ?? 'NO ACTION')}</code></div>` : ''}
                    ` : (fk.diffType === 'added' && fk.target ? `<div>→ <code>${escapeHtml(fk.target.referencedTable)}.${escapeHtml(fk.target.referencedColumn)}</code></div>` : fk.diffType === 'removed' && fk.source ? `<div>→ <code>${escapeHtml(fk.source.referencedTable)}.${escapeHtml(fk.source.referencedColumn)}</code></div>` : '')}
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      ` : ''}

      ${triggerDiffs && triggerDiffs.length > 0 ? `
        <div class="diff-section">
          <h4>Trigger Changes (${triggerDiffs.length})</h4>
          <table>
            <thead>
              <tr>
                <th>Trigger</th>
                <th>Type</th>
                <th>Details</th>
              </tr>
            </thead>
            <tbody>
              ${triggerDiffs.map((trg) => `
                <tr class="${trg.diffType}">
                  <td><strong>${escapeHtml(trg.name)}</strong></td>
                  <td><span class="badge ${trg.diffType}">${trg.diffType.toUpperCase()}</span></td>
                  <td>
                    ${trg.changes ? `
                      ${trg.changes.timing ? `<div>Timing: <code>${escapeHtml(trg.changes.timing.from)}</code> → <code>${escapeHtml(trg.changes.timing.to)}</code></div>` : ''}
                      ${trg.changes.event ? `<div>Event: <code>${escapeHtml(trg.changes.event.from)}</code> → <code>${escapeHtml(trg.changes.event.to)}</code></div>` : ''}
                      ${trg.changes.sql ? `<div>SQL definition changed</div>` : ''}
                    ` : (trg.diffType === 'added' && trg.target ? `<div>${escapeHtml(trg.target.timing)} ${escapeHtml(trg.target.event)}</div>` : trg.diffType === 'removed' && trg.source ? `<div>${escapeHtml(trg.source.timing)} ${escapeHtml(trg.source.event)}</div>` : '')}
                  </td>
                </tr>
              `).join('')}
            </tbody>
          </table>
        </div>
      ` : ''}
    </div>
  `;
}

/**
 * Generates inline CSS styles for the HTML report
 */
function generateStyles(): string {
  return `
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #1f2937;
      background-color: #f9fafb;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px;
    }

    header h1 {
      font-size: 32px;
      font-weight: 700;
      margin-bottom: 20px;
    }

    .metadata p {
      margin: 8px 0;
      font-size: 14px;
      opacity: 0.95;
    }

    section {
      padding: 40px;
      border-bottom: 1px solid #e5e7eb;
    }

    section:last-of-type {
      border-bottom: none;
    }

    h2 {
      font-size: 24px;
      font-weight: 600;
      margin-bottom: 24px;
      color: #111827;
    }

    h3 {
      font-size: 18px;
      font-weight: 600;
      color: #111827;
    }

    h4 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #374151;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
      margin-bottom: 24px;
    }

    .summary-card {
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
    }

    .summary-card.added {
      background: #ecfdf5;
      border-color: #86efac;
    }

    .summary-card.removed {
      background: #fef2f2;
      border-color: #fca5a5;
    }

    .summary-card.modified {
      background: #fef3c7;
      border-color: #fcd34d;
    }

    .summary-label {
      font-size: 12px;
      font-weight: 500;
      text-transform: uppercase;
      color: #6b7280;
      margin-bottom: 8px;
      letter-spacing: 0.05em;
    }

    .summary-value {
      font-size: 32px;
      font-weight: 700;
      color: #111827;
    }

    .changes-summary {
      background: #f9fafb;
      border-radius: 8px;
      padding: 20px;
    }

    .changes-summary h3 {
      font-size: 16px;
      margin-bottom: 12px;
    }

    .changes-summary ul {
      list-style: none;
      padding: 0;
    }

    .changes-summary li {
      padding: 4px 0;
      font-size: 14px;
      color: #4b5563;
    }

    .no-changes {
      color: #6b7280;
      font-style: italic;
      text-align: center;
      padding: 40px;
    }

    .table-diff {
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      margin-bottom: 24px;
      overflow: hidden;
    }

    .table-diff.added {
      border-left: 4px solid #22c55e;
    }

    .table-diff.removed {
      border-left: 4px solid #ef4444;
    }

    .table-diff.modified {
      border-left: 4px solid #f59e0b;
    }

    .table-header {
      background: #f9fafb;
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #e5e7eb;
    }

    .badge {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .badge.added {
      background: #dcfce7;
      color: #166534;
    }

    .badge.removed {
      background: #fee2e2;
      color: #991b1b;
    }

    .badge.modified {
      background: #fef3c7;
      color: #92400e;
    }

    .badge.unchanged {
      background: #f3f4f6;
      color: #4b5563;
    }

    .diff-section {
      padding: 20px;
      border-bottom: 1px solid #f3f4f6;
    }

    .diff-section:last-child {
      border-bottom: none;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }

    thead {
      background: #f9fafb;
      border-bottom: 2px solid #e5e7eb;
    }

    th {
      text-align: left;
      padding: 12px;
      font-weight: 600;
      color: #374151;
    }

    td {
      padding: 12px;
      border-bottom: 1px solid #f3f4f6;
    }

    tbody tr:last-child td {
      border-bottom: none;
    }

    tbody tr.added {
      background: #f0fdf4;
    }

    tbody tr.removed {
      background: #fef2f2;
    }

    tbody tr.modified {
      background: #fffbeb;
    }

    code {
      background: #f3f4f6;
      padding: 2px 6px;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 13px;
      color: #1f2937;
    }

    footer {
      background: #f9fafb;
      padding: 20px 40px;
      text-align: center;
      color: #6b7280;
      font-size: 14px;
    }

    @media print {
      body {
        background: white;
        padding: 0;
      }

      .container {
        box-shadow: none;
      }
    }
  </style>
  `;
}

/**
 * Escapes HTML special characters to prevent XSS
 */
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  };
  return text.replace(/[&<>"']/g, (char) => map[char] || char);
}

/**
 * Formats ISO timestamp to readable date/time
 */
function formatTimestamp(isoString: string): string {
  const date = new Date(isoString);
  return date.toLocaleString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  });
}

// ============ JSON Report Generator ============

export interface JSONReportOptions {
  /** Pretty-print with indentation (defaults to true) */
  prettyPrint?: boolean;
  /** Indentation size when pretty-printing (defaults to 2) */
  indent?: number;
}

/**
 * Generates JSON report for programmatic use.
 * Exports the entire comparison result as JSON.
 *
 * @param comparisonResult - The schema comparison result to export
 * @param options - JSON report configuration
 * @returns JSON formatted string
 */
export function generateJSONReport(
  comparisonResult: SchemaComparisonResult,
  options: JSONReportOptions = {}
): string {
  const { prettyPrint = true, indent = 2 } = options;

  // Add metadata to the report
  const report = {
    reportGeneratedAt: new Date().toISOString(),
    comparisonResult,
  };

  if (prettyPrint) {
    return JSON.stringify(report, null, indent);
  }
  return JSON.stringify(report);
}

// ============ Markdown Report Generator ============

export interface MarkdownReportOptions {
  /** Title for the report (defaults to 'Schema Comparison Report') */
  title?: string;
  /** Include detailed change information (defaults to true) */
  includeDetails?: boolean;
}

/**
 * Generates Markdown report for documentation.
 * Creates a human-readable markdown document with the comparison results.
 *
 * @param comparisonResult - The schema comparison result to export
 * @param options - Markdown report configuration
 * @returns Markdown formatted string
 */
export function generateMarkdownReport(
  comparisonResult: SchemaComparisonResult,
  options: MarkdownReportOptions = {}
): string {
  const { title = 'Schema Comparison Report', includeDetails = true } = options;

  const { sourceType, sourceName, targetType, targetName, comparedAt, tableDiffs, summary } =
    comparisonResult;

  let markdown = `# ${title}\n\n`;

  // Metadata section
  markdown += `## Metadata\n\n`;
  markdown += `- **Source:** ${sourceName} (${sourceType})\n`;
  markdown += `- **Target:** ${targetName} (${targetType})\n`;
  markdown += `- **Compared At:** ${new Date(comparedAt).toLocaleString()}\n`;
  markdown += `- **Report Generated:** ${new Date().toLocaleString()}\n\n`;

  // Summary section
  markdown += `## Summary\n\n`;
  markdown += `| Metric | Count |\n`;
  markdown += `|--------|-------|\n`;
  markdown += `| Source Tables | ${summary.sourceTables} |\n`;
  markdown += `| Target Tables | ${summary.targetTables} |\n`;
  markdown += `| Tables Added | ${summary.tablesAdded} |\n`;
  markdown += `| Tables Removed | ${summary.tablesRemoved} |\n`;
  markdown += `| Tables Modified | ${summary.tablesModified} |\n`;
  markdown += `| Tables Unchanged | ${summary.tablesUnchanged} |\n`;

  if (
    summary.totalColumnChanges +
      summary.totalIndexChanges +
      summary.totalForeignKeyChanges +
      summary.totalTriggerChanges >
    0
  ) {
    markdown += `\n### Total Changes\n\n`;
    if (summary.totalColumnChanges > 0) {
      markdown += `- **Columns:** ${summary.totalColumnChanges}\n`;
    }
    if (summary.totalIndexChanges > 0) {
      markdown += `- **Indexes:** ${summary.totalIndexChanges}\n`;
    }
    if (summary.totalForeignKeyChanges > 0) {
      markdown += `- **Foreign Keys:** ${summary.totalForeignKeyChanges}\n`;
    }
    if (summary.totalTriggerChanges > 0) {
      markdown += `- **Triggers:** ${summary.totalTriggerChanges}\n`;
    }
  }

  markdown += `\n`;

  // Table differences section
  markdown += `## Table Differences\n\n`;

  if (tableDiffs.length === 0) {
    markdown += `*No differences found.*\n\n`;
  } else {
    // Group tables by diff type
    const addedTables = tableDiffs.filter((t) => t.diffType === 'added');
    const removedTables = tableDiffs.filter((t) => t.diffType === 'removed');
    const modifiedTables = tableDiffs.filter((t) => t.diffType === 'modified');

    if (addedTables.length > 0) {
      markdown += `### Added Tables (${addedTables.length})\n\n`;
      for (const table of addedTables) {
        markdown += `- **${table.name}**`;
        if (includeDetails && table.target) {
          markdown += ` (${table.target.columns.length} columns)`;
        }
        markdown += `\n`;
      }
      markdown += `\n`;
    }

    if (removedTables.length > 0) {
      markdown += `### Removed Tables (${removedTables.length})\n\n`;
      for (const table of removedTables) {
        markdown += `- **${table.name}**`;
        if (includeDetails && table.source) {
          markdown += ` (${table.source.columns.length} columns)`;
        }
        markdown += `\n`;
      }
      markdown += `\n`;
    }

    if (modifiedTables.length > 0) {
      markdown += `### Modified Tables (${modifiedTables.length})\n\n`;
      for (const table of modifiedTables) {
        markdown += `#### ${table.name}\n\n`;

        // Column changes
        if (table.columnDiffs && table.columnDiffs.length > 0) {
          markdown += `**Column Changes (${table.columnDiffs.length}):**\n\n`;
          markdown += `| Column | Type | Details |\n`;
          markdown += `|--------|------|----------|\n`;

          for (const col of table.columnDiffs) {
            let details = '';
            if (col.changes) {
              const changes: string[] = [];
              if (col.changes.type) {
                changes.push(`Type: \`${col.changes.type.from}\` → \`${col.changes.type.to}\``);
              }
              if (col.changes.nullable) {
                changes.push(
                  `Nullable: \`${col.changes.nullable.from}\` → \`${col.changes.nullable.to}\``
                );
              }
              if (col.changes.defaultValue) {
                changes.push(
                  `Default: \`${col.changes.defaultValue.from ?? 'NULL'}\` → \`${col.changes.defaultValue.to ?? 'NULL'}\``
                );
              }
              if (col.changes.isPrimaryKey) {
                changes.push(
                  `PK: \`${col.changes.isPrimaryKey.from}\` → \`${col.changes.isPrimaryKey.to}\``
                );
              }
              details = changes.join('<br/>');
            } else if (col.diffType === 'added' && col.target) {
              details = `Type: \`${col.target.type}\`, Nullable: ${col.target.nullable}`;
            } else if (col.diffType === 'removed' && col.source) {
              details = `Type: \`${col.source.type}\`, Nullable: ${col.source.nullable}`;
            }

            markdown += `| ${col.name} | ${col.diffType.toUpperCase()} | ${details} |\n`;
          }
          markdown += `\n`;
        }

        // Index changes
        if (table.indexDiffs && table.indexDiffs.length > 0) {
          markdown += `**Index Changes (${table.indexDiffs.length}):**\n\n`;
          for (const idx of table.indexDiffs) {
            markdown += `- **${idx.name}** (${idx.diffType.toUpperCase()})`;
            if (idx.changes) {
              const changes: string[] = [];
              if (idx.changes.columns) {
                changes.push(
                  `Columns: \`${idx.changes.columns.from.join(', ')}\` → \`${idx.changes.columns.to.join(', ')}\``
                );
              }
              if (idx.changes.isUnique) {
                changes.push(
                  `Unique: \`${idx.changes.isUnique.from}\` → \`${idx.changes.isUnique.to}\``
                );
              }
              if (changes.length > 0) {
                markdown += `: ${changes.join(', ')}`;
              }
            } else if (idx.diffType === 'added' && idx.target) {
              markdown += `: Columns: \`${idx.target.columns.join(', ')}\`, Unique: ${idx.target.isUnique}`;
            } else if (idx.diffType === 'removed' && idx.source) {
              markdown += `: Columns: \`${idx.source.columns.join(', ')}\`, Unique: ${idx.source.isUnique}`;
            }
            markdown += `\n`;
          }
          markdown += `\n`;
        }

        // Foreign key changes
        if (table.foreignKeyDiffs && table.foreignKeyDiffs.length > 0) {
          markdown += `**Foreign Key Changes (${table.foreignKeyDiffs.length}):**\n\n`;
          for (const fk of table.foreignKeyDiffs) {
            markdown += `- **${fk.column}** (${fk.diffType.toUpperCase()})`;
            if (fk.changes) {
              const changes: string[] = [];
              if (fk.changes.referencedTable) {
                changes.push(
                  `Ref Table: \`${fk.changes.referencedTable.from}\` → \`${fk.changes.referencedTable.to}\``
                );
              }
              if (fk.changes.referencedColumn) {
                changes.push(
                  `Ref Column: \`${fk.changes.referencedColumn.from}\` → \`${fk.changes.referencedColumn.to}\``
                );
              }
              if (fk.changes.onDelete) {
                changes.push(
                  `On Delete: \`${fk.changes.onDelete.from}\` → \`${fk.changes.onDelete.to}\``
                );
              }
              if (fk.changes.onUpdate) {
                changes.push(
                  `On Update: \`${fk.changes.onUpdate.from}\` → \`${fk.changes.onUpdate.to}\``
                );
              }
              if (changes.length > 0) {
                markdown += `: ${changes.join(', ')}`;
              }
            } else if (fk.diffType === 'added' && fk.target) {
              markdown += `: → \`${fk.target.referencedTable}.${fk.target.referencedColumn}\``;
            } else if (fk.diffType === 'removed' && fk.source) {
              markdown += `: → \`${fk.source.referencedTable}.${fk.source.referencedColumn}\``;
            }
            markdown += `\n`;
          }
          markdown += `\n`;
        }

        // Trigger changes
        if (table.triggerDiffs && table.triggerDiffs.length > 0) {
          markdown += `**Trigger Changes (${table.triggerDiffs.length}):**\n\n`;
          for (const trg of table.triggerDiffs) {
            markdown += `- **${trg.name}** (${trg.diffType.toUpperCase()})`;
            if (trg.changes) {
              const changes: string[] = [];
              if (trg.changes.timing) {
                changes.push(
                  `Timing: \`${trg.changes.timing.from}\` → \`${trg.changes.timing.to}\``
                );
              }
              if (trg.changes.event) {
                changes.push(`Event: \`${trg.changes.event.from}\` → \`${trg.changes.event.to}\``);
              }
              if (trg.changes.sql) {
                changes.push('SQL definition changed');
              }
              if (changes.length > 0) {
                markdown += `: ${changes.join(', ')}`;
              }
            } else if (trg.diffType === 'added' && trg.target) {
              markdown += `: ${trg.target.timing} ${trg.target.event}`;
            } else if (trg.diffType === 'removed' && trg.source) {
              markdown += `: ${trg.source.timing} ${trg.source.event}`;
            }
            markdown += `\n`;
          }
          markdown += `\n`;
        }
      }
    }
  }

  markdown += `---\n\n`;
  markdown += `*Generated by SQL Pro - Schema Comparison Tool*\n`;

  return markdown;
}
